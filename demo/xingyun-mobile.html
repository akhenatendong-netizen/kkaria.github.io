<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Point Cloud</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        .info h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .info p {
            font-size: 14px;
            color: #ddd;
        }
        
        /* Mobile-friendly controls at the bottom */
        .controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .control-panel {
            width: 100%;
            max-width: 600px;
            color: white;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            margin: 0 5px;
            flex: 1;
        }
        
        .control-label {
            font-size: 12px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        
        .slider-value {
            width: 30px;
            text-align: right;
            margin-left: 8px;
            font-size: 12px;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
        }
        
        .toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-right: 8px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 20px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #2196F3;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .button-row {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        .control-button {
            padding: 8px 16px;
            margin: 0 5px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        
        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Toggle for control panel visibility */
        .panel-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            cursor: pointer;
            z-index: 101;
            font-size: 14px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                margin: 5px 0;
            }
            
            .button-row {
                flex-wrap: wrap;
            }
            
            .control-button {
                margin: 5px;
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Cosmic Point Cloud</h1>
        <p>An interactive 3D visualization of a galaxy-like point cloud.</p>
    </div>
    
    <div class="panel-toggle" id="panelToggle">Show Controls</div>
    
    <div class="controls-container" id="controlsContainer" style="display: none;">
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group">
                    <div class="control-label">Spread Speed</div>
                    <div class="slider-container">
                        <input type="range" min="1" max="20" value="5" class="slider" id="spreadSpeed">
                        <div class="slider-value" id="spreadSpeedValue">0.05</div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">Spread Duration (s)</div>
                    <div class="slider-container">
                        <input type="range" min="5" max="20" value="10" class="slider" id="spreadDuration">
                        <div class="slider-value" id="spreadDurationValue">10</div>
                    </div>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <div class="control-label">Rotation Speed</div>
                    <div class="slider-container">
                        <input type="range" min="0" max="20" value="8" class="slider" id="rotationSpeed">
                        <div class="slider-value" id="rotationSpeedValue">0.08</div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">Arms</div>
                    <div class="slider-container">
                        <input type="range" min="1" max="8" value="6" class="slider" id="arms">
                        <div class="slider-value" id="armsValue">6</div>
                    </div>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <div class="toggle-container">
                        <label class="toggle">
                            <input type="checkbox" id="fadeOut" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="control-label">Fade Out</div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="toggle-container">
                        <label class="toggle">
                            <input type="checkbox" id="autoSpread" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="control-label">Auto Spread</div>
                    </div>
                </div>
            </div>
            
            <div class="button-row">
                <button class="control-button" id="triggerSpread">Trigger Diffusion</button>
                <button class="control-button" id="resetGalaxy">Reset Galaxy</button>
                <button class="control-button" id="hideControls">Hide Controls</button>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Animation states
        const STATES = {
            INIT: 'init',
            DIFFUSE: 'diffuse',
            AGGREGATE: 'aggregate',
            HOLD: 'hold',
            SPREAD: 'spread'
        };
        
        let currentState = STATES.INIT;
        let stateStartTime = 0;
        let lastFrameTime = 0;
        
        // Galaxy parameters
        const params = {
            particleCount: 30000,
            arms: 6,
            armTurns: 3,
            spin: 1.8,
            maxRadius: 5,
            randomness: 0.4,
            randomnessPower: 2.5,
            heightFactor: 0.08,
            rotationSpeed: 0.08,
            morphProgress: 0,
            // Spreading parameters
            spreadEnabled: false,
            spreadSpeed: 0.05,
            spreadDuration: 10,
            fadeOut: true,
            autoSpread: true,
            autoSpreadDelay: 10 // seconds after formation before auto-spreading
        };
        
        // Spreading state
        const spreadState = {
            active: false,
            startTime: 0,
            progress: 0
        };
        
        // Initial blob parameters
        const blobParams = {
            arms: 1,
            spin: 0,
            randomness: 1.5,
            randomnessPower: 1.2,
            heightFactor: 0.2
        };
        
        // 3D perspective settings
        const perspective = {
            focalLength: 500,
            cameraZ: 1000,
            rotationX: 0.2,
            rotationY: 0,
            rotationZ: 0,
            autoRotate: true
        };
        
        // Mouse interaction
        const mouse = {
            x: 0,
            y: 0,
            isDown: false,
            lastX: 0,
            lastY: 0
        };
        
        // Touch interaction
        const touch = {
            active: false,
            startX: 0,
            startY: 0
        };
        
        // Particle class
        class Particle {
            constructor() {
                // Initialize with random position in a sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = Math.random() * 50;
                
                this.x3d = radius * Math.sin(phi) * Math.cos(theta);
                this.y3d = radius * Math.sin(phi) * Math.sin(theta);
                this.z3d = radius * Math.cos(phi);
                
                this.targetX = 0;
                this.targetY = 0;
                this.targetZ = 0;
                
                this.originalX = 0;
                this.originalY = 0;
                this.originalZ = 0;
                
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                
                this.size = Math.random() * 1.5 + 0.5;
                this.color = '#ffffff';
                this.alpha = 1;
                
                // For 2D projection
                this.x2d = 0;
                this.y2d = 0;
                this.scale = 1;
                
                // For radius calculation
                this.radius = 0;
            }
            
            // Project 3D coordinates to 2D screen
            project() {
                // Apply rotation
                const cosX = Math.cos(perspective.rotationX);
                const sinX = Math.sin(perspective.rotationX);
                const cosY = Math.cos(perspective.rotationY);
                const sinY = Math.sin(perspective.rotationY);
                const cosZ = Math.cos(perspective.rotationZ);
                const sinZ = Math.sin(perspective.rotationZ);
                
                // Rotation around X axis
                let y1 = this.y3d * cosX - this.z3d * sinX;
                let z1 = this.y3d * sinX + this.z3d * cosX;
                
                // Rotation around Y axis
                let x2 = this.x3d * cosY + z1 * sinY;
                let z2 = -this.x3d * sinY + z1 * cosY;
                
                // Rotation around Z axis
                let x3 = x2 * cosZ - y1 * sinZ;
                let y3 = x2 * sinZ + y1 * cosZ;
                
                // Perspective projection
                const scale = perspective.focalLength / (perspective.focalLength + z2 + perspective.cameraZ);
                this.x2d = x3 * scale + canvas.width / 2;
                this.y2d = y3 * scale + canvas.height / 2;
                this.scale = scale;
                
                // Adjust alpha based on z position and spread progress
                let baseAlpha = Math.min(1, Math.max(0.1, (1000 + z2) / 1500));
                
                // Apply fade out during spread if enabled
                if (spreadState.active && params.fadeOut) {
                    // Calculate distance from center
                    const distance = Math.sqrt(this.x3d * this.x3d + this.y3d * this.y3d + this.z3d * this.z3d);
                    const maxDistance = 1000; // Arbitrary large value
                    const normalizedDistance = Math.min(distance / maxDistance, 1);
                    
                    // Fade based on distance and spread progress
                    baseAlpha *= Math.max(0, 1 - (normalizedDistance * spreadState.progress * 1.5));
                }
                
                this.alpha = baseAlpha;
            }
            
            // Update particle position
            update(deltaTime) {
                // Different behavior based on animation state
                switch(currentState) {
                    case STATES.DIFFUSE:
                        this.diffuse();
                        break;
                    case STATES.AGGREGATE:
                        this.aggregate();
                        break;
                    case STATES.HOLD:
                        this.hold();
                        break;
                    case STATES.SPREAD:
                        this.spread(deltaTime);
                        break;
                }
                
                // Apply velocity
                this.x3d += this.vx;
                this.y3d += this.vy;
                this.z3d += this.vz;
                
                // Apply friction
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.vz *= 0.98;
                
                // Calculate radius from center
                this.radius = Math.sqrt(this.x3d * this.x3d + this.y3d * this.y3d + this.z3d * this.z3d);
                
                // Project to 2D
                this.project();
            }
            
            // Diffuse outward
            diffuse() {
                // Calculate direction from center
                const dx = this.x3d;
                const dy = this.y3d;
                const dz = this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 0) {
                    // Normalize direction
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const nz = dz / distance;
                    
                    // Apply force outward
                    const force = 0.05;
                    this.vx += nx * force;
                    this.vy += ny * force;
                    this.vz += nz * force;
                }
                
                // Add some randomness
                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
                this.vz += (Math.random() - 0.5) * 0.1;
            }
            
            // Aggregate into galaxy shape
            aggregate() {
                // Calculate current parameters based on morph progress
                const currentParams = {};
                for (const key of ['arms', 'spin', 'randomness', 'randomnessPower', 'heightFactor']) {
                    currentParams[key] = lerp(
                        blobParams[key],
                        params[key],
                        params.morphProgress
                    );
                }
                
                // Calculate distance to target
                const dx = this.targetX - this.x3d;
                const dy = this.targetY - this.y3d;
                const dz = this.targetZ - this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 1) {
                    // Move toward target
                    this.vx += dx * 0.01;
                    this.vy += dy * 0.01;
                    this.vz += dz * 0.01;
                } else {
                    // Arrived at target
                    this.x3d = this.targetX + (Math.random() * 2 - 1);
                    this.y3d = this.targetY + (Math.random() * 2 - 1);
                    this.z3d = this.targetZ + (Math.random() * 2 - 1);
                    
                    // Store original position for spreading
                    this.originalX = this.x3d;
                    this.originalY = this.y3d;
                    this.originalZ = this.z3d;
                }
            }
            
            // Hold position with subtle movement
            hold() {
                // Subtle movement
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;
                this.vz += (Math.random() - 0.5) * 0.02;
                
                // Stay near target
                const dx = this.targetX - this.x3d;
                const dy = this.targetY - this.y3d;
                const dz = this.targetZ - this.z3d;
                
                this.vx += dx * 0.01;
                this.vy += dy * 0.01;
                this.vz += dz * 0.01;
            }
            
            // Spread outward
            spread(deltaTime) {
                // Calculate direction from center
                const dx = this.x3d;
                const dy = this.y3d;
                const dz = this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 0) {
                    // Normalize direction
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const nz = dz / distance;
                    
                    // Apply outward force based on radius
                    // Inner particles move slower than outer particles
                    const radiusFactor = Math.min(1, this.radius / 100);
                    const speedFactor = lerp(0.2, 1, radiusFactor); // Inner particles move at 20% speed
                    
                    const spreadForce = params.spreadSpeed * speedFactor;
                    
                    this.vx += nx * spreadForce * deltaTime * 60; // Normalize to 60fps
                    this.vy += ny * spreadForce * deltaTime * 60;
                    this.vz += nz * spreadForce * deltaTime * 60;
                }
            }
            
            // Draw particle
            draw() {
                const size = this.size * this.scale;
                if (size < 0.1) return;
                
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x2d, this.y2d, size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }
        
        // Helper function for linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        
        // Particles array
        const particles = [];
        
        // Initialize particles
        function init() {
            // Create particles
            for (let i = 0; i < params.particleCount; i++) {
                particles.push(new Particle());
            }
            
            // Set initial state
            currentState = STATES.INIT;
            stateStartTime = Date.now();
            
            // Start animation sequence
            setTimeout(() => startDiffusion(), 1000);
        }
        
        // Start diffusion phase
        function startDiffusion() {
            currentState = STATES.DIFFUSE;
            stateStartTime = Date.now();
            
            // Schedule next phase
            setTimeout(() => {
                calculateGalaxyTargets();
                startAggregation();
            }, 3000);
        }
        
        // Calculate galaxy target positions
        function calculateGalaxyTargets() {
            const particlesPerArm = params.particleCount / params.arms;
            
            for (let i = 0; i < params.particleCount; i++) {
                // Determine which arm this particle belongs to
                const armIndex = i % params.arms;
                const armAngleOffset = armIndex * (Math.PI * 2 / params.arms);
                
                // Progress along the arm (0 to 1)
                const t = (i / particlesPerArm) % 1;
                
                // Base angle calculation
                const baseAngle = t * params.armTurns * Math.PI * 2 + armAngleOffset;
                
                // Radius with power distribution (denser toward center)
                const radius = Math.pow(Math.random(), params.randomnessPower) * params.maxRadius * 50;
                
                // Apply spiral twist
                const angle = baseAngle + radius * params.spin * 0.01;
                
                // Random offsets with decreasing randomness toward the edge
                const randomX = (Math.random() * 2 - 1) * params.randomness * Math.pow(1 - t, params.randomnessPower) * 20;
                const randomY = (Math.random() * 2 - 1) * params.randomness * params.heightFactor * 20;
                const randomZ = (Math.random() * 2 - 1) * params.randomness * Math.pow(1 - t, params.randomnessPower) * 20;
                
                // Final positions
                particles[i].targetX = Math.cos(angle) * radius + randomX;
                particles[i].targetY = randomY;
                particles[i].targetZ = Math.sin(angle) * radius + randomZ;
                
                // Colors - whiter in center, grayer at edges
                const mixRatio = radius / (params.maxRadius * 50);
                const brightness = Math.floor(255 - mixRatio * 50);
                particles[i].color = `rgb(${brightness}, ${brightness}, ${brightness})`;
            }
        }
        
        // Start aggregation phase
        function startAggregation() {
            params.morphProgress = 0;
            
            // Animate morph progress
            const startTime = Date.now();
            const duration = 2500; // 2.5 seconds
            
            function updateMorph() {
                const elapsed = Date.now() - startTime;
                params.morphProgress = Math.min(1, elapsed / duration);
                
                if (params.morphProgress < 1) {
                    requestAnimationFrame(updateMorph);
                } else {
                    // When morph is complete, move to hold state
                    setTimeout(() => holdShape(), 1000);
                }
            }
            
            currentState = STATES.AGGREGATE;
            stateStartTime = Date.now();
            updateMorph();
        }
        
        // Hold final shape
        function holdShape() {
            currentState = STATES.HOLD;
            stateStartTime = Date.now();
            
            // Schedule auto-spread if enabled
            if (params.autoSpread) {
                setTimeout(() => {
                    if (currentState === STATES.HOLD) {
                        startSpread();
                    }
                }, params.autoSpreadDelay * 1000);
            }
        }
        
        // Start spreading phase
        function startSpread() {
            if (currentState !== STATES.HOLD) return;
            
            currentState = STATES.SPREAD;
            spreadState.active = true;
            spreadState.startTime = Date.now();
            spreadState.progress = 0;
            
            // Update button text
            document.getElementById('triggerSpread').textContent = 'Spreading...';
        }
        
        // Reset galaxy
        function resetGalaxy() {
            // Reset spread state
            spreadState.active = false;
            spreadState.progress = 0;
            
            // Reset particles to their original positions
            for (let i = 0; i < particles.length; i++) {
                particles[i].x3d = particles[i].originalX;
                particles[i].y3d = particles[i].originalY;
                particles[i].z3d = particles[i].originalZ;
                particles[i].vx = 0;
                particles[i].vy = 0;
                particles[i].vz = 0;
                particles[i].alpha = 1;
            }
            
            // Reset state
            currentState = STATES.HOLD;
            
            // Update button text
            document.getElementById('triggerSpread').textContent = 'Trigger Diffusion';
        }
        
        // Animation loop
        function animate(timestamp) {
            // Calculate delta time
            const deltaTime = (timestamp - lastFrameTime) / 1000; // in seconds
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Auto-rotate
            if (perspective.autoRotate && currentState !== STATES.SPREAD) {
                perspective.rotationY += params.rotationSpeed * 0.001;
            }
            
            // Update spread progress
            if (spreadState.active) {
                const elapsed = (Date.now() - spreadState.startTime) / 1000; // in seconds
                spreadState.progress = Math.min(1, elapsed / params.spreadDuration);
                
                // If spreading is complete, keep the state
                if (spreadState.progress >= 1) {
                    spreadState.progress = 1;
                }
            }
            
            // Update and draw particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].update(deltaTime);
            }
            
            // Sort particles by z for proper depth
            particles.sort((a, b) => b.z3d - a.z3d);
            
            // Draw particles
            ctx.globalCompositeOperation = 'lighter'; // Additive blending
            for (let i = 0; i < particles.length; i++) {
                particles[i].draw();
            }
            ctx.globalCompositeOperation = 'source-over';
            
            // Continue animation
            requestAnimationFrame(animate);
        }
        
        // Initialize UI controls
        function initControls() {
            // Spread speed slider
            const spreadSpeedSlider = document.getElementById('spreadSpeed');
            const spreadSpeedValue = document.getElementById('spreadSpeedValue');
            spreadSpeedSlider.addEventListener('input', () => {
                params.spreadSpeed = spreadSpeedSlider.value / 100;
                spreadSpeedValue.textContent = params.spreadSpeed.toFixed(2);
            });
            
            // Spread duration slider
            const spreadDurationSlider = document.getElementById('spreadDuration');
            const spreadDurationValue = document.getElementById('spreadDurationValue');
            spreadDurationSlider.addEventListener('input', () => {
                params.spreadDuration = parseInt(spreadDurationSlider.value);
                spreadDurationValue.textContent = params.spreadDuration;
            });
            
            // Rotation speed slider
            const rotationSpeedSlider = document.getElementById('rotationSpeed');
            const rotationSpeedValue = document.getElementById('rotationSpeedValue');
            rotationSpeedSlider.addEventListener('input', () => {
                params.rotationSpeed = rotationSpeedSlider.value / 100;
                rotationSpeedValue.textContent = params.rotationSpeed.toFixed(2);
            });
            
            // Arms slider
            const armsSlider = document.getElementById('arms');
            const armsValue = document.getElementById('armsValue');
            armsSlider.addEventListener('input', () => {
                params.arms = parseInt(armsSlider.value);
                armsValue.textContent = params.arms;
                calculateGalaxyTargets();
            });
            
            // Fade out toggle
            const fadeOutToggle = document.getElementById('fadeOut');
            fadeOutToggle.addEventListener('change', () => {
                params.fadeOut = fadeOutToggle.checked;
            });
            
            // Auto spread toggle
            const autoSpreadToggle = document.getElementById('autoSpread');
            autoSpreadToggle.addEventListener('change', () => {
                params.autoSpread = autoSpreadToggle.checked;
            });
            
            // Trigger spread button
            const triggerSpreadButton = document.getElementById('triggerSpread');
            triggerSpreadButton.addEventListener('click', () => {
                if (!spreadState.active) {
                    startSpread();
                }
            });
            
            // Reset galaxy button
            const resetGalaxyButton = document.getElementById('resetGalaxy');
            resetGalaxyButton.addEventListener('click', resetGalaxy);
            
            // Panel toggle
            const panelToggle = document.getElementById('panelToggle');
            const controlsContainer = document.getElementById('controlsContainer');
            const hideControlsButton = document.getElementById('hideControls');
            
            panelToggle.addEventListener('click', () => {
                controlsContainer.style.display = 'flex';
                panelToggle.style.display = 'none';
            });
            
            hideControlsButton.addEventListener('click', () => {
                controlsContainer.style.display = 'none';
                panelToggle.style.display = 'block';
            });
        }
        
        // Mouse event handlers
        canvas.addEventListener('mousemove', (e) => {
            if (mouse.isDown) {
                // Rotate based on mouse movement
                perspective.rotationY += (e.clientX - mouse.lastX) * 0.005;
                perspective.rotationX += (e.clientY - mouse.lastY) * 0.005;
                perspective.autoRotate = false;
            }
            
            mouse.lastX = e.clientX;
            mouse.lastY = e.clientY;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            mouse.lastX = e.clientX;
            mouse.lastY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
        });
        
        // Touch event handlers for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touch.active = true;
                touch.startX = e.touches[0].clientX;
                touch.startY = e.touches[0].clientY;
                mouse.lastX = touch.startX;
                mouse.lastY = touch.startY;
                e.preventDefault();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touch.active && e.touches.length === 1) {
                // Rotate based on touch movement
                perspective.rotationY += (e.touches[0].clientX - mouse.lastX) * 0.005;
                perspective.rotationX += (e.touches[0].clientY - mouse.lastY) * 0.005;
                perspective.autoRotate = false;
                
                mouse.lastX = e.touches[0].clientX;
                mouse.lastY = e.touches[0].clientY;
                e.preventDefault();
            }
        });
        
        canvas.addEventListener('touchend', () => {
            touch.active = false;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Initialize controls
        initControls();
        
        // Initialize and start animation
        init();
        lastFrameTime = performance.now();
        animate(lastFrameTime);
    </script>
</body>
</html>
