<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Point Cloud</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        .info h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .info p {
            font-size: 14px;
            color: #ddd;
        }
        
        .footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        .gui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        .spread-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            font-family: Arial, sans-serif;
            cursor: pointer;
            transition: background-color 0.3s;
            z-index: 10;
        }
        
        .spread-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Cosmic Point Cloud</h1>
        <p>An interactive 3D visualization of a galaxy-like point cloud.</p>
    </div>
    
    <div class="footer">
        Use the mouse to navigate the 3D space.
    </div>
    
    <div class="gui-container"></div>
    
    <button class="spread-button">Trigger Diffusion</button>

    <!-- Import Three.js and related libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.2/dist/lil-gui.umd.min.js"></script>

    <script>
        // Canvas setup
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Animation states
        const STATES = {
            INIT: 'init',
            DIFFUSE: 'diffuse',
            AGGREGATE: 'aggregate',
            HOLD: 'hold',
            SPREAD: 'spread'
        };
        
        let currentState = STATES.INIT;
        let stateStartTime = 0;
        let lastFrameTime = 0;
        
        // Galaxy parameters
        const params = {
            particleCount: 30000,
            arms: 6,
            armTurns: 3,
            spin: 1.8,
            maxRadius: 5,
            randomness: 0.4,
            randomnessPower: 2.5,
            heightFactor: 0.08,
            rotationSpeed: 0.08,
            morphProgress: 0,
            // Spreading parameters
            spreadEnabled: false,
            spreadSpeed: 0.05,
            spreadDuration: 10,
            fadeOut: true,
            autoSpread: true,
            autoSpreadDelay: 10 // seconds after formation before auto-spreading
        };
        
        // Spreading state
        const spreadState = {
            active: false,
            startTime: 0,
            progress: 0
        };
        
        // Initial blob parameters
        const blobParams = {
            arms: 1,
            spin: 0,
            randomness: 1.5,
            randomnessPower: 1.2,
            heightFactor: 0.2
        };
        
        // 3D perspective settings
        const perspective = {
            focalLength: 500,
            cameraZ: 1000,
            rotationX: 0.2,
            rotationY: 0,
            rotationZ: 0,
            autoRotate: true
        };
        
        // Mouse interaction
        const mouse = {
            x: 0,
            y: 0,
            isDown: false
        };
        
        // Particle class
        class Particle {
            constructor() {
                // Initialize with random position in a sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = Math.random() * 50;
                
                this.x3d = radius * Math.sin(phi) * Math.cos(theta);
                this.y3d = radius * Math.sin(phi) * Math.sin(theta);
                this.z3d = radius * Math.cos(phi);
                
                this.targetX = 0;
                this.targetY = 0;
                this.targetZ = 0;
                
                this.originalX = 0;
                this.originalY = 0;
                this.originalZ = 0;
                
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                
                this.size = Math.random() * 1.5 + 0.5;
                this.color = '#ffffff';
                this.alpha = 1;
                
                // For 2D projection
                this.x2d = 0;
                this.y2d = 0;
                this.scale = 1;
                
                // For radius calculation
                this.radius = 0;
            }
            
            // Project 3D coordinates to 2D screen
            project() {
                // Apply rotation
                const cosX = Math.cos(perspective.rotationX);
                const sinX = Math.sin(perspective.rotationX);
                const cosY = Math.cos(perspective.rotationY);
                const sinY = Math.sin(perspective.rotationY);
                const cosZ = Math.cos(perspective.rotationZ);
                const sinZ = Math.sin(perspective.rotationZ);
                
                // Rotation around X axis
                let y1 = this.y3d * cosX - this.z3d * sinX;
                let z1 = this.y3d * sinX + this.z3d * cosX;
                
                // Rotation around Y axis
                let x2 = this.x3d * cosY + z1 * sinY;
                let z2 = -this.x3d * sinY + z1 * cosY;
                
                // Rotation around Z axis
                let x3 = x2 * cosZ - y1 * sinZ;
                let y3 = x2 * sinZ + y1 * cosZ;
                
                // Perspective projection
                const scale = perspective.focalLength / (perspective.focalLength + z2 + perspective.cameraZ);
                this.x2d = x3 * scale + canvas.width / 2;
                this.y2d = y3 * scale + canvas.height / 2;
                this.scale = scale;
                
                // Adjust alpha based on z position and spread progress
                let baseAlpha = Math.min(1, Math.max(0.1, (1000 + z2) / 1500));
                
                // Apply fade out during spread if enabled
                if (spreadState.active && params.fadeOut) {
                    // Calculate distance from center
                    const distance = Math.sqrt(this.x3d * this.x3d + this.y3d * this.y3d + this.z3d * this.z3d);
                    const maxDistance = 1000; // Arbitrary large value
                    const normalizedDistance = Math.min(distance / maxDistance, 1);
                    
                    // Fade based on distance and spread progress
                    baseAlpha *= Math.max(0, 1 - (normalizedDistance * spreadState.progress * 1.5));
                }
                
                this.alpha = baseAlpha;
            }
            
            // Update particle position
            update(deltaTime) {
                // Different behavior based on animation state
                switch(currentState) {
                    case STATES.DIFFUSE:
                        this.diffuse();
                        break;
                    case STATES.AGGREGATE:
                        this.aggregate();
                        break;
                    case STATES.HOLD:
                        this.hold();
                        break;
                    case STATES.SPREAD:
                        this.spread(deltaTime);
                        break;
                }
                
                // Apply velocity
                this.x3d += this.vx;
                this.y3d += this.vy;
                this.z3d += this.vz;
                
                // Apply friction
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.vz *= 0.98;
                
                // Calculate radius from center
                this.radius = Math.sqrt(this.x3d * this.x3d + this.y3d * this.y3d + this.z3d * this.z3d);
                
                // Project to 2D
                this.project();
            }
            
            // Diffuse outward
            diffuse() {
                // Calculate direction from center
                const dx = this.x3d;
                const dy = this.y3d;
                const dz = this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 0) {
                    // Normalize direction
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const nz = dz / distance;
                    
                    // Apply force outward
                    const force = 0.05;
                    this.vx += nx * force;
                    this.vy += ny * force;
                    this.vz += nz * force;
                }
                
                // Add some randomness
                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
                this.vz += (Math.random() - 0.5) * 0.1;
            }
            
            // Aggregate into galaxy shape
            aggregate() {
                // Calculate current parameters based on morph progress
                const currentParams = {};
                for (const key of ['arms', 'spin', 'randomness', 'randomnessPower', 'heightFactor']) {
                    currentParams[key] = lerp(
                        blobParams[key],
                        params[key],
                        params.morphProgress
                    );
                }
                
                // Calculate distance to target
                const dx = this.targetX - this.x3d;
                const dy = this.targetY - this.y3d;
                const dz = this.targetZ - this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 1) {
                    // Move toward target
                    this.vx += dx * 0.01;
                    this.vy += dy * 0.01;
                    this.vz += dz * 0.01;
                } else {
                    // Arrived at target
                    this.x3d = this.targetX + (Math.random() * 2 - 1);
                    this.y3d = this.targetY + (Math.random() * 2 - 1);
                    this.z3d = this.targetZ + (Math.random() * 2 - 1);
                    
                    // Store original position for spreading
                    this.originalX = this.x3d;
                    this.originalY = this.y3d;
                    this.originalZ = this.z3d;
                }
            }
            
            // Hold position with subtle movement
            hold() {
                // Subtle movement
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;
                this.vz += (Math.random() - 0.5) * 0.02;
                
                // Stay near target
                const dx = this.targetX - this.x3d;
                const dy = this.targetY - this.y3d;
                const dz = this.targetZ - this.z3d;
                
                this.vx += dx * 0.01;
                this.vy += dy * 0.01;
                this.vz += dz * 0.01;
            }
            
            // Spread outward
            spread(deltaTime) {
                // Calculate direction from center
                const dx = this.x3d;
                const dy = this.y3d;
                const dz = this.z3d;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance > 0) {
                    // Normalize direction
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const nz = dz / distance;
                    
                    // Apply outward force based on radius
                    // Inner particles move slower than outer particles
                    const radiusFactor = Math.min(1, this.radius / 100);
                    const speedFactor = lerp(0.2, 1, radiusFactor); // Inner particles move at 20% speed
                    
                    const spreadForce = params.spreadSpeed * speedFactor;
                    
                    this.vx += nx * spreadForce * deltaTime * 60; // Normalize to 60fps
                    this.vy += ny * spreadForce * deltaTime * 60;
                    this.vz += nz * spreadForce * deltaTime * 60;
                }
            }
            
            // Draw particle
            draw() {
                const size = this.size * this.scale;
                if (size < 0.1) return;
                
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x2d, this.y2d, size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }
        
        // Helper function for linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        
        // Particles array
        const particles = [];
        
        // Initialize particles
        function init() {
            // Create particles
            for (let i = 0; i < params.particleCount; i++) {
                particles.push(new Particle());
            }
            
            // Set initial state
            currentState = STATES.INIT;
            stateStartTime = Date.now();
            
            // Start animation sequence
            setTimeout(() => startDiffusion(), 1000);
        }
        
        // Start diffusion phase
        function startDiffusion() {
            currentState = STATES.DIFFUSE;
            stateStartTime = Date.now();
            
            // Schedule next phase
            setTimeout(() => {
                calculateGalaxyTargets();
                startAggregation();
            }, 3000);
        }
        
        // Calculate galaxy target positions
        function calculateGalaxyTargets() {
            const particlesPerArm = params.particleCount / params.arms;
            
            for (let i = 0; i < params.particleCount; i++) {
                // Determine which arm this particle belongs to
                const armIndex = i % params.arms;
                const armAngleOffset = armIndex * (Math.PI * 2 / params.arms);
                
                // Progress along the arm (0 to 1)
                const t = (i / particlesPerArm) % 1;
                
                // Base angle calculation
                const baseAngle = t * params.armTurns * Math.PI * 2 + armAngleOffset;
                
                // Radius with power distribution (denser toward center)
                const radius = Math.pow(Math.random(), params.randomnessPower) * params.maxRadius * 50;
                
                // Apply spiral twist
                const angle = baseAngle + radius * params.spin * 0.01;
                
                // Random offsets with decreasing randomness toward the edge
                const randomX = (Math.random() * 2 - 1) * params.randomness * Math.pow(1 - t, params.randomnessPower) * 20;
                const randomY = (Math.random() * 2 - 1) * params.randomness * params.heightFactor * 20;
                const randomZ = (Math.random() * 2 - 1) * params.randomness * Math.pow(1 - t, params.randomnessPower) * 20;
                
                // Final positions
                particles[i].targetX = Math.cos(angle) * radius + randomX;
                particles[i].targetY = randomY;
                particles[i].targetZ = Math.sin(angle) * radius + randomZ;
                
                // Colors - whiter in center, grayer at edges
                const mixRatio = radius / (params.maxRadius * 50);
                const brightness = Math.floor(255 - mixRatio * 50);
                particles[i].color = `rgb(${brightness}, ${brightness}, ${brightness})`;
            }
        }
        
        // Start aggregation phase
        function startAggregation() {
            params.morphProgress = 0;
            
            // Animate morph progress
            const startTime = Date.now();
            const duration = 2500; // 2.5 seconds
            
            function updateMorph() {
                const elapsed = Date.now() - startTime;
                params.morphProgress = Math.min(1, elapsed / duration);
                
                if (params.morphProgress < 1) {
                    requestAnimationFrame(updateMorph);
                } else {
                    // When morph is complete, move to hold state
                    setTimeout(() => holdShape(), 1000);
                }
            }
            
            currentState = STATES.AGGREGATE;
            stateStartTime = Date.now();
            updateMorph();
        }
        
        // Hold final shape
        function holdShape() {
            currentState = STATES.HOLD;
            stateStartTime = Date.now();
            
            // Schedule auto-spread if enabled
            if (params.autoSpread) {
                setTimeout(() => {
                    if (currentState === STATES.HOLD) {
                        startSpread();
                    }
                }, params.autoSpreadDelay * 1000);
            }
        }
        
        // Start spreading phase
        function startSpread() {
            if (currentState !== STATES.HOLD) return;
            
            currentState = STATES.SPREAD;
            spreadState.active = true;
            spreadState.startTime = Date.now();
            spreadState.progress = 0;
            
            // Update button text
            document.querySelector('.spread-button').textContent = 'Spreading...';
        }
        
        // Animation loop
        function animate(timestamp) {
            // Calculate delta time
            const deltaTime = (timestamp - lastFrameTime) / 1000; // in seconds
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Auto-rotate
            if (perspective.autoRotate && currentState !== STATES.SPREAD) {
                perspective.rotationY += 0.002;
            }
            
            // Update spread progress
            if (spreadState.active) {
                const elapsed = (Date.now() - spreadState.startTime) / 1000; // in seconds
                spreadState.progress = Math.min(1, elapsed / params.spreadDuration);
                
                // If spreading is complete, keep the state
                if (spreadState.progress >= 1) {
                    spreadState.progress = 1;
                }
            }
            
            // Update and draw particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].update(deltaTime);
            }
            
            // Sort particles by z for proper depth
            particles.sort((a, b) => b.z3d - a.z3d);
            
            // Draw particles
            ctx.globalCompositeOperation = 'lighter'; // Additive blending
            for (let i = 0; i < particles.length; i++) {
                particles[i].draw();
            }
            ctx.globalCompositeOperation = 'source-over';
            
            // Continue animation
            requestAnimationFrame(animate);
        }
        
        // Mouse event handlers
        canvas.addEventListener('mousemove', (e) => {
            const prevX = mouse.x;
            const prevY = mouse.y;
            
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            if (mouse.isDown) {
                // Rotate based on mouse movement
                perspective.rotationY += (mouse.x - prevX) * 0.005;
                perspective.rotationX += (mouse.y - prevY) * 0.005;
            }
        });
        
        canvas.addEventListener('mousedown', () => {
            mouse.isDown = true;
            perspective.autoRotate = false;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
        });
        
        // Spread button event handler
        document.querySelector('.spread-button').addEventListener('click', () => {
            if (!spreadState.active) {
                startSpread();
            }
        });
        
        // GUI setup
        const gui = new lil.GUI({ container: document.querySelector('.gui-container') });
        
        // Galaxy folder
        const galaxyFolder = gui.addFolder('Galaxy Parameters');
        galaxyFolder.add(params, 'particleCount', 10000, 100000, 1000).name('Particle Count').onChange(() => {
            // Recreate particles
            particles.length = 0;
            init();
        });
        galaxyFolder.add(params, 'arms', 1, 8, 1).name('Arms').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'armTurns', 1, 6, 0.1).name('Arm Turns').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'spin', 0, 3, 0.01).name('Spin').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'maxRadius', 2, 8, 0.1).name('Max Radius').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'randomness', 0, 2, 0.01).name('Randomness').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'randomnessPower', 1, 5, 0.1).name('Randomness Power').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'heightFactor', 0, 0.4, 0.01).name('Height Factor').onChange(calculateGalaxyTargets);
        galaxyFolder.add(params, 'rotationSpeed', 0, 0.4, 0.01).name('Rotation Speed');
        
        // Spread folder
        const spreadFolder = gui.addFolder('Diffusion Parameters');
        spreadFolder.add(params, 'spreadSpeed', 0.01, 0.2, 0.01).name('Spread Speed');
        spreadFolder.add(params, 'spreadDuration', 5, 20, 1).name('Spread Duration (s)');
        spreadFolder.add(params, 'fadeOut').name('Fade Out');
        spreadFolder.add(params, 'autoSpread').name('Auto Spread');
        spreadFolder.add(params, 'autoSpreadDelay', 5, 30, 1).name('Auto Delay (s)');
        
        const spreadController = {
            triggerSpread: () => {
                if (!spreadState.active) {
                    startSpread();
                }
            },
            resetGalaxy: () => {
                // Reset spread state
                spreadState.active = false;
                spreadState.progress = 0;
                
                // Reset particles to their original positions
                for (let i = 0; i < particles.length; i++) {
                    particles[i].x3d = particles[i].originalX;
                    particles[i].y3d = particles[i].originalY;
                    particles[i].z3d = particles[i].originalZ;
                    particles[i].vx = 0;
                    particles[i].vy = 0;
                    particles[i].vz = 0;
                    particles[i].alpha = 1;
                }
                
                // Reset state
                currentState = STATES.HOLD;
                
                // Update button text
                document.querySelector('.spread-button').textContent = 'Trigger Diffusion';
            }
        };
        
        spreadFolder.add(spreadController, 'triggerSpread').name('Start Diffusion');
        spreadFolder.add(spreadController, 'resetGalaxy').name('Reset Galaxy');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Initialize and start animation
        init();
        lastFrameTime = performance.now();
        animate(lastFrameTime);
    </script>
</body>
</html>