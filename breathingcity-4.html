<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crystal Breathing City</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 16px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 0 0 5px #000;
    }
    #controls {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 1000;
      display: flex;
      gap: 12px;
    }
    .control-btn {
      background-color: rgba(40, 44, 80, 0.6);
      border: none;
      color: white;
      padding: 12px 16px;
      text-align: center;
      font-size: 16px;
      cursor: pointer;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      box-shadow: 0 0 10px rgba(20, 20, 40, 0.3);
      min-width: 100px;
      min-height: 44px;
    }
    .control-btn:hover {
      background-color: rgba(50, 54, 100, 0.7);
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      background-color: #0A0C12;
      z-index: 1000;
    }
    
    /* Responsive layout */
    @media (max-width: 480px) {
      #controls {
        flex-direction: column;
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="info">Crystal Breathing City - Click to increase heartbeat, hover for nature effect</div>
  <div id="controls">
    <button id="resetBtn" class="control-btn">Reset Breathing</button>
    <button id="musicBtn" class="control-btn">Music: Off</button>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Configuration
    const config = {
      gridSize: 32,
      cellSize: 1,
      baseHeight: 2,
      breatheSpeed: 0.4, // Slower breathing
      baseAmplitude: 1.5,
      amplitudeFalloff: 0.08,
      phaseOffset: 0.2,
      hoverRadius: 5,
      emissiveIntensity: 0.15,
      glassOpacity: 0.9,
      glassShininess: 30,
      uiGap: 14,
      controlsZ: 1000,
      waveSpeed: 8,
      waveAmplitude: 1.5,
      waveDamping: 1.2,
      ringWidthDamping: 0.4,
      calmPalette: {
        base: '#2B4CA9', // Updated base blue
        ripple: '#2FA5A0', // Teal for ripple effect
        rippleHighlight: '#3AC6B0', // Brighter teal for wave peaks
        fog: '#0A0C12', // Dark background
        emissive: '#16203A' // Subtle glow
      },
      music: {
        enabled: false,
        src: 'assets/ambient.mp3'
      },
      sfx: {
        heartbeat: {
          enabled: true,
          src: 'synth'
        },
        minInterval: 0.3 // Slower heartbeat sound
      }
    };
    
    // Wait for Three.js to load
    window.addEventListener('load', function() {
      // State variables
      let heartbeatLevel = 0;
      let anxietyLevel = 0;
      let lastClickTime = 0;
      let clickCount = 0;
      let lastHeartbeatTime = 0;
      let clickPoints = []; // Store click points for ripple effect
      
      // Audio variables
      let audioContext;
      let backgroundMusic;
      let musicSource;
      
      // Main variables
      let scene, camera, renderer, controls;
      let instancedMesh, dummy;
      let buildings = [];
      let mouse = new THREE.Vector2();
      let raycaster = new THREE.Raycaster();
      let ground, clock;
      
      // Check for stored music preference
      if (localStorage.getItem('musicEnabled') === 'true') {
        config.music.enabled = true;
        document.getElementById('musicBtn').textContent = 'Music: On';
      }
      
      // Initialize
      init();
      animate();
      
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(config.calmPalette.fog);
        scene.fog = new THREE.FogExp2(config.calmPalette.fog, 0.02);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(config.gridSize / 2, config.gridSize / 2, config.gridSize);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // Create orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = config.gridSize * 1.5;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minPolarAngle = Math.PI / 6;
        
        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(
          config.gridSize * config.cellSize * 1.5, 
          config.gridSize * config.cellSize * 1.5
        );
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: config.calmPalette.fog,
          roughness: 0.8,
          metalness: 0.2,
          emissive: config.calmPalette.fog,
          emissiveIntensity: 0.15
        });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        scene.add(ground);
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x333344, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x8888aa, 0.8);
        directionalLight.position.set(config.gridSize, config.gridSize, config.gridSize);
        scene.add(directionalLight);
        
        // Add point lights for glass effect - more subtle
        const blueLight = new THREE.PointLight(0x4466aa, 0.8, config.gridSize * 2);
        blueLight.position.set(config.gridSize/2, config.gridSize/2, config.gridSize/2);
        scene.add(blueLight);
        
        const purpleLight = new THREE.PointLight(0x445588, 0.5, config.gridSize * 3);
        purpleLight.position.set(-config.gridSize/3, config.gridSize/4, -config.gridSize/3);
        scene.add(purpleLight);
        
        // Create city
        createCity();
        
        // Setup clock
        clock = new THREE.Clock();
        
        // Initialize audio
        initAudio();
        
        // Add event listeners
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        document.getElementById('resetBtn').addEventListener('click', resetBreathing);
        document.getElementById('musicBtn').addEventListener('click', toggleMusic);
        
        // Hide loading screen
        document.getElementById('loading').style.display = 'none';
      }
      
      function initAudio() {
        try {
          // Create audio context
          window.AudioContext = window.AudioContext || window.webkitAudioContext;
          audioContext = new AudioContext();
          
          // Create master gain
          const masterGain = audioContext.createGain();
          masterGain.gain.value = 0.4; // Lower overall volume
          masterGain.connect(audioContext.destination);
          
          // Setup background music
          if (config.music.enabled) {
            loadBackgroundMusic();
          }
          
        } catch (e) {
          console.error("Web Audio API is not supported in this browser");
        }
      }
      
      function loadBackgroundMusic() {
        if (!audioContext) return;
        
        // For now, we'll use synthesized ambient music
        // TODO: Replace with actual ambient.mp3 file when available
        
        // Create oscillators for ambient music - more soothing
        backgroundMusic = {
          oscillators: [],
          gains: [],
          isPlaying: false
        };
        
        // Create base frequencies for a pleasant chord (more soothing)
        const baseFrequencies = [
          220, // A3
          293.66, // D4
          349.23, // F4
          440, // A4
        ];
        
        // Create oscillators
        for (let i = 0; i < baseFrequencies.length; i++) {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          // Use sine waves for smoother sound
          oscillator.type = 'sine';
          oscillator.frequency.value = baseFrequencies[i];
          
          // Set initial gain to 0
          gainNode.gain.value = 0;
          
          // Connect nodes
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Start oscillator
          oscillator.start();
          
          // Store references
          backgroundMusic.oscillators.push(oscillator);
          backgroundMusic.gains.push(gainNode);
        }
        
        // Start music if enabled
        if (config.music.enabled) {
          startMusic();
        }
      }
      
      function startMusic() {
        if (!audioContext || !backgroundMusic) return;
        
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        // Fade in very slowly
        backgroundMusic.gains.forEach((gainNode, i) => {
          gainNode.gain.cancelScheduledValues(audioContext.currentTime);
          gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(0.03 / backgroundMusic.gains.length, audioContext.currentTime + 3);
        });
        
        backgroundMusic.isPlaying = true;
      }
      
      function stopMusic() {
        if (!audioContext || !backgroundMusic) return;
        
        // Fade out slowly
        backgroundMusic.gains.forEach((gainNode) => {
          gainNode.gain.cancelScheduledValues(audioContext.currentTime);
          gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
        });
        
        backgroundMusic.isPlaying = false;
      }
      
      function toggleMusic() {
        if (!audioContext) {
          initAudio();
        }
        
        config.music.enabled = !config.music.enabled;
        
        // Save preference
        localStorage.setItem('musicEnabled', config.music.enabled);
        
        if (config.music.enabled) {
          if (!backgroundMusic) {
            loadBackgroundMusic();
          } else {
            startMusic();
          }
          document.getElementById('musicBtn').textContent = "Music: On";
        } else {
          stopMusic();
          document.getElementById('musicBtn').textContent = "Music: Off";
        }
      }
      
      function updateMusic(elapsedTime, heartbeatLevel, anxietyLevel) {
        if (!config.music.enabled || !backgroundMusic || !backgroundMusic.isPlaying) return;
        
        // Update oscillator frequencies based on breathing - more subtle
        const breathePhase = Math.sin(elapsedTime * config.breatheSpeed);
        
        backgroundMusic.oscillators.forEach((osc, i) => {
          // Very subtle frequency modulation
          const baseFreq = osc.frequency.value;
          const detune = breathePhase * 3 + heartbeatLevel * 5 + anxietyLevel * 10;
          osc.detune.value = detune;
          
          // Adjust volume based on anxiety - more subtle
          const gain = backgroundMusic.gains[i];
          const targetVolume = 0.03 / backgroundMusic.gains.length * (1 - anxietyLevel * 0.3);
          gain.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.2);
        });
      }
      
      function playHeartbeat(intensity = 0.5) {
        if (!audioContext || !config.sfx.heartbeat.enabled) return;
        
        // Check if we should throttle the heartbeat sound
        const currentTime = clock.getElapsedTime();
        if (currentTime - lastHeartbeatTime < config.sfx.minInterval) {
          return;
        }
        lastHeartbeatTime = currentTime;
        
        // Ensure audio context is running
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        const t0 = audioContext.currentTime;
        const g = audioContext.createGain();
        g.connect(audioContext.destination);
        
        const o = audioContext.createOscillator();
        o.type = 'sine';
        o.connect(g);
        
        // Lower base frequency and volume for gentler heartbeat
        const base = 50; // Hz (lower)
        const vol = 0.15 + 0.5 * intensity; // Lower volume range
        const pitch = base * (1 + 0.2 * intensity); // Less pitch variation
        
        // First beat - gentler
        g.gain.setValueAtTime(0, t0);
        g.gain.linearRampToValueAtTime(vol, t0 + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25); // Longer decay
        
        o.frequency.setValueAtTime(pitch, t0);
        o.start(t0);
        o.stop(t0 + 0.3);
        
        // Second beat (lub-dub) - gentler and slower
        setTimeout(() => {
          const o2 = audioContext.createOscillator();
          const g2 = audioContext.createGain();
          
          o2.type = 'sine';
          o2.connect(g2);
          g2.connect(audioContext.destination);
          
          g2.gain.setValueAtTime(0, audioContext.currentTime);
          g2.gain.linearRampToValueAtTime(vol * 0.8, audioContext.currentTime + 0.03);
          g2.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.25);
          
          o2.frequency.setValueAtTime(pitch * 0.9, audioContext.currentTime);
          o2.start();
          o2.stop(audioContext.currentTime + 0.3);
        }, 180); // Slower rhythm
      }
      
      function createCity() {
        // Create building geometry
        const geometry = new THREE.BoxGeometry(
          config.cellSize * 0.8, 
          1, 
          config.cellSize * 0.8
        );
        geometry.translate(0, 0.5, 0); // Move pivot to bottom
        
        // Create glass material - using the calm palette
        const material = new THREE.MeshPhongMaterial({
          color: new THREE.Color(config.calmPalette.base),
          emissive: new THREE.Color(config.calmPalette.emissive),
          emissiveIntensity: config.emissiveIntensity,
          specular: 0x8899aa,
          shininess: config.glassShininess,
          transparent: true,
          opacity: config.glassOpacity,
          reflectivity: 0.8
        });
        
        // Create instanced mesh
        const totalBuildings = config.gridSize * config.gridSize;
        instancedMesh = new THREE.InstancedMesh(geometry, material, totalBuildings);
        scene.add(instancedMesh);
        
        // Initialize buildings
        dummy = new THREE.Object3D();
        const centerX = config.gridSize / 2;
        const centerZ = config.gridSize / 2;
        const offset = (config.gridSize * config.cellSize) / 2 - config.cellSize / 2;
        
        for (let i = 0; i < config.gridSize; i++) {
          for (let j = 0; j < config.gridSize; j++) {
            const index = i * config.gridSize + j;
            
            // Calculate position
            const x = i * config.cellSize - offset;
            const z = j * config.cellSize - offset;
            
            // Calculate distance from center
            const dx = i - centerX;
            const dz = j - centerZ;
            const distanceToCenter = Math.sqrt(dx * dx + dz * dz);
            
            // Store building data
            buildings.push({
              position: new THREE.Vector3(x, 0, z),
              currentHeight: config.baseHeight,
              targetHeight: config.baseHeight,
              index,
              i,
              j,
              distanceToCenter,
              natureEffect: 0,
              rippleEffect: 0,
              // Add subtle color variation based on position
              colorShift: (Math.sin(i * 0.2) * 0.5 + 0.5) * (Math.cos(j * 0.3) * 0.5 + 0.5) * 0.05
            });
            
            // Set initial matrix
            dummy.position.set(x, 0, z);
            dummy.scale.set(1, config.baseHeight, 1);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(index, dummy.matrix);
          }
        }
        
        instancedMesh.instanceMatrix.needsUpdate = true;
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function onMouseMove(event) {
        // Update mouse position
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      
      function onClick() {
        const currentTime = clock.getElapsedTime();
        
        // Increase heartbeat level
        heartbeatLevel = Math.min(1, heartbeatLevel + 0.2);
        
        // Track click frequency for anxiety
        if (currentTime - lastClickTime < 0.5) {
          clickCount++;
          if (clickCount > 3) {
            anxietyLevel = Math.min(1, anxietyLevel + 0.2);
          }
        } else {
          clickCount = Math.max(0, clickCount - 1);
        }
        
        lastClickTime = currentTime;
        
        // Create ripple effect from click point
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);
        
        if (intersects.length > 0) {
          const point = intersects[0].point;
          
          // Convert to grid coordinates
          const gridX = (point.x + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          const gridZ = (point.z + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          
          // Add click point for ripple effect
          clickPoints.push({
            position: new THREE.Vector2(gridX, gridZ),
            time: currentTime,
            intensity: 1.0
          });
        }
        
        // Play heartbeat sound with intensity based on anxiety level
        playHeartbeat(0.3 + anxietyLevel * 0.7);
      }
      
      function resetBreathing() {
        heartbeatLevel = 0;
        anxietyLevel = 0;
        clickCount = 0;
        clickPoints = []; // Clear ripple effects
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        const deltaTime = clock.getDelta();
        const elapsedTime = clock.getElapsedTime();
        
        // Update controls
        controls.update();
        
        // Update raycaster for hover effect
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);
        let hoverPoint = null;
        
        if (intersects.length > 0) {
          const point = intersects[0].point;
          
          // Convert to grid coordinates
          const gridX = (point.x + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          const gridZ = (point.z + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          
          hoverPoint = new THREE.Vector2(gridX, gridZ);
        }
        
        // Gradually reduce heartbeat and anxiety levels
        heartbeatLevel = Math.max(0, heartbeatLevel - deltaTime * 0.1);
        anxietyLevel = Math.max(0, anxietyLevel - deltaTime * 0.05);
        
        // Update buildings
        updateBuildings(deltaTime, elapsedTime, hoverPoint);
        
        // Update material color based on anxiety level
        updateCityMood(elapsedTime);
        
        // Update music
        updateMusic(elapsedTime, heartbeatLevel, anxietyLevel);
        
        // Render scene
        renderer.render(scene, camera);
      }
      
      function updateBuildings(deltaTime, elapsedTime, hoverPoint) {
        const smooth = 0.15;
        const dt60 = deltaTime * 60;
        const smoothFactor = 1 - Math.pow(1 - smooth, dt60);
        
        // Calculate breathing parameters based on heartbeat level
        const breatheSpeed = config.breatheSpeed * (1 + heartbeatLevel * 3);
        
        // Reset effects on all buildings
        for (const building of buildings) {
          building.natureEffect = 0;
          building.rippleEffect = 0;
        }
        
        // Apply nature effect to buildings near hover point
        if (hoverPoint) {
          for (const building of buildings) {
            const dx = building.i - hoverPoint.x;
            const dz = building.j - hoverPoint.y;
            const distanceToHover = Math.sqrt(dx * dx + dz * dz);
            
            if (distanceToHover < config.hoverRadius) {
              building.natureEffect = 1 - distanceToHover / config.hoverRadius;
            }
          }
        }
        
        // Apply ripple effect from click points
        const activeClickPoints = [];
        
        for (const clickPoint of clickPoints) {
          const age = elapsedTime - clickPoint.time;
          
          // Only keep active ripples
          if (age < 5) {
            activeClickPoints.push(clickPoint);
            
            // Calculate ripple wave front
            const waveFront = config.waveSpeed * age;
            
            // Apply to buildings
            for (const building of buildings) {
              const dx = building.i - clickPoint.position.x;
              const dz = building.j - clickPoint.position.y;
              const distanceToClick = Math.sqrt(dx * dx + dz * dz);
              
              // Calculate ripple effect
              const envelope = Math.exp(-age * config.waveDamping) * 
                              Math.exp(-Math.abs(distanceToClick - waveFront) * config.ringWidthDamping);
              
              const waveDelta = Math.sin(distanceToClick * 0.5 - age * 3) * 
                               config.waveAmplitude * envelope;
              
              // Add ripple effect (only if positive to create teal color only on wave peaks)
              if (waveDelta > 0) {
                building.rippleEffect = Math.max(building.rippleEffect, waveDelta);
              }
            }
          }
        }
        
        // Update click points array
        clickPoints = activeClickPoints;
        
        // Update each building
        for (const building of buildings) {
          // Calculate base height with breathing effect
          const localPhase = building.distanceToCenter * config.phaseOffset;
          const localAmplitude = config.baseAmplitude * Math.exp(-building.distanceToCenter * config.amplitudeFalloff);
          
          let targetHeight = config.baseHeight + 
            Math.sin(elapsedTime * breatheSpeed + localPhase) * localAmplitude;
          
          // Add anxiety jitter
          if (anxietyLevel > 0) {
            targetHeight += (Math.random() - 0.5) * anxietyLevel * 0.5;
          }
          
          // Add nature effect (make buildings taller)
          if (building.natureEffect > 0) {
            targetHeight += building.natureEffect * 1.5;
          }
          
          // Add ripple effect
          if (building.rippleEffect > 0) {
            targetHeight += building.rippleEffect;
          }
          
          // Ensure minimum height
          targetHeight = Math.max(0.1, targetHeight);
          
          // Smooth transition to target height
          building.targetHeight = targetHeight;
          building.currentHeight += (building.targetHeight - building.currentHeight) * smoothFactor;
          
          // Update matrix
          dummy.position.copy(building.position);
          dummy.position.y = building.currentHeight / 2;
          dummy.scale.set(1, building.currentHeight, 1);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(building.index, dummy.matrix);
        }
        
        instancedMesh.instanceMatrix.needsUpdate = true;
      }
      
      function updateCityMood(elapsedTime) {
        // Base colors - using calm palette
        const calmColor = new THREE.Color(config.calmPalette.base);
        const calmEmissive = new THREE.Color(config.calmPalette.emissive);
        
        // Ripple colors
        const rippleColor = new THREE.Color(config.calmPalette.ripple);
        const rippleHighlightColor = new THREE.Color(config.calmPalette.rippleHighlight);
        
        // Anxious colors - still desaturated
        const anxiousColor = new THREE.Color('#A57C6C');
        const anxiousEmissive = new THREE.Color('#332A24');
        
        // Start with calm color
        let finalColor = calmColor.clone();
        let finalEmissive = calmEmissive.clone();
        
        // Blend with anxious color based on anxiety level
        if (anxietyLevel > 0) {
          finalColor.lerp(anxiousColor, anxietyLevel);
          finalEmissive.lerp(anxiousEmissive, anxietyLevel);
        }
        
        // Check if any buildings have nature effect
        let hasNatureEffect = false;
        let maxNatureEffect = 0;
        
        // Check if any buildings have ripple effect
        let hasRippleEffect = false;
        let maxRippleEffect = 0;
        
        for (const building of buildings) {
          if (building.natureEffect > 0) {
            hasNatureEffect = true;
            maxNatureEffect = Math.max(maxNatureEffect, building.natureEffect);
          }
          
          if (building.rippleEffect > 0) {
            hasRippleEffect = true;
            maxRippleEffect = Math.max(maxRippleEffect, building.rippleEffect);
          }
        }
        
        // Subtle color pulsing
        const pulseAmount = Math.sin(elapsedTime * 0.5) * 0.03 + 0.97;
        finalColor.multiplyScalar(pulseAmount);
        
        // Add color variation based on breathing - using HSL for subtle shifts
        const breathePhase = Math.sin(elapsedTime * config.breatheSpeed);
        const hueShift = breathePhase * 0.02; // Very subtle hue shift
        
        // Convert to HSL for easier hue manipulation
        const hsl = {};
        finalColor.getHSL(hsl);
        
        // Apply subtle HSL shift without increasing saturation
        finalColor.setHSL(
          hsl.h + hueShift, 
          hsl.s, // Keep saturation the same
          hsl.l + breathePhase * 0.03 // Subtle lightness variation
        );
        
        // Update material colors
        instancedMesh.material.color.copy(finalColor);
        instancedMesh.material.emissive.copy(finalEmissive);
        
        // Create color attribute for individual building colors if needed
        if (hasRippleEffect && !instancedMesh.geometry.attributes.instanceColor) {
          const colorArray = new Float32Array(buildings.length * 3);
          instancedMesh.geometry.setAttribute(
            'instanceColor',
            new THREE.InstancedBufferAttribute(colorArray, 3)
          );
        }
        
        // Update individual building colors for ripple effect
        if (hasRippleEffect && instancedMesh.geometry.attributes.instanceColor) {
          const colorAttribute = instancedMesh.geometry.attributes.instanceColor;
          
          for (let i = 0; i < buildings.length; i++) {
            const building = buildings[i];
            let color = finalColor.clone();
            
            // Apply ripple effect color
            if (building.rippleEffect > 0) {
              // Blend between ripple color and ripple highlight based on effect strength
              const rippleBlendColor = rippleColor.clone().lerp(
                rippleHighlightColor, 
                building.rippleEffect / maxRippleEffect
              );
              
              // Blend with base color based on ripple effect strength
              color.lerp(rippleBlendColor, building.rippleEffect);
            }
            
            // Set color in attribute
            colorAttribute.setXYZ(i, color.r, color.g, color.b);
          }
          
          colorAttribute.needsUpdate = true;
        }
      }
    });
  </script>
</body>
</html>
