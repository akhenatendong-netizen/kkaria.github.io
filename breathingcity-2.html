<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glass Breathing City</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 16px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 0 0 5px #000;
    }
    #resetBtn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(76, 175, 80, 0.7);
      border: none;
      color: white;
      padding: 10px 15px;
      text-align: center;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      z-index: 100;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 0 10px rgba(0, 255, 128, 0.3);
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      background-color: #000;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="info">Glass Breathing City - Click to increase heartbeat, hover for nature effect</div>
  <button id="resetBtn">Reset Breathing</button>
  
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Wait for Three.js to load
    window.addEventListener('load', function() {
      // Configuration
      const config = {
        gridSize: 32,
        cellSize: 1,
        baseHeight: 2,
        breatheSpeed: 0.5,
        baseAmplitude: 1.5,
        amplitudeFalloff: 0.08,
        phaseOffset: 0.2,
        hoverRadius: 5,
        emissiveIntensity: 0.3,
        glassOpacity: 0.7,
        glassShininess: 30
      };
      
      // State variables
      let heartbeatLevel = 0;
      let anxietyLevel = 0;
      let lastClickTime = 0;
      let clickCount = 0;
      
      // Main variables
      let scene, camera, renderer, controls;
      let instancedMesh, dummy;
      let buildings = [];
      let mouse = new THREE.Vector2();
      let raycaster = new THREE.Raycaster();
      let ground, clock;
      let bloomPass, composer;
      
      // Initialize
      init();
      animate();
      
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(config.gridSize / 2, config.gridSize / 2, config.gridSize);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // Create orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = config.gridSize * 1.5;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minPolarAngle = Math.PI / 6;
        
        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(
          config.gridSize * config.cellSize * 1.5, 
          config.gridSize * config.cellSize * 1.5
        );
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x111122,
          roughness: 0.8,
          metalness: 0.2,
          emissive: 0x001122,
          emissiveIntensity: 0.1
        });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        scene.add(ground);
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x333344, 1);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xaaaaff, 1);
        directionalLight.position.set(config.gridSize, config.gridSize, config.gridSize);
        scene.add(directionalLight);
        
        // Add point lights for glass effect
        const blueLight = new THREE.PointLight(0x0044ff, 1, config.gridSize * 2);
        blueLight.position.set(config.gridSize/2, config.gridSize/2, config.gridSize/2);
        scene.add(blueLight);
        
        const purpleLight = new THREE.PointLight(0x440088, 0.5, config.gridSize * 3);
        purpleLight.position.set(-config.gridSize/3, config.gridSize/4, -config.gridSize/3);
        scene.add(purpleLight);
        
        // Create city
        createCity();
        
        // Setup clock
        clock = new THREE.Clock();
        
        // Add event listeners
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        document.getElementById('resetBtn').addEventListener('click', resetBreathing);
        
        // Hide loading screen
        document.getElementById('loading').style.display = 'none';
      }
      
      function createCity() {
        // Create building geometry
        const geometry = new THREE.BoxGeometry(
          config.cellSize * 0.8, 
          1, 
          config.cellSize * 0.8
        );
        geometry.translate(0, 0.5, 0); // Move pivot to bottom
        
        // Create glass material
        const material = new THREE.MeshPhongMaterial({
          color: 0x88ccff,
          emissive: 0x0055aa,
          emissiveIntensity: config.emissiveIntensity,
          specular: 0xffffff,
          shininess: config.glassShininess,
          transparent: true,
          opacity: config.glassOpacity,
          reflectivity: 1,
          refractionRatio: 0.98,
          depthWrite: false,
          blending: THREE.NormalBlending
        });
        
        // Create instanced mesh
        const totalBuildings = config.gridSize * config.gridSize;
        instancedMesh = new THREE.InstancedMesh(geometry, material, totalBuildings);
        scene.add(instancedMesh);
        
        // Initialize buildings
        dummy = new THREE.Object3D();
        const centerX = config.gridSize / 2;
        const centerZ = config.gridSize / 2;
        const offset = (config.gridSize * config.cellSize) / 2 - config.cellSize / 2;
        
        for (let i = 0; i < config.gridSize; i++) {
          for (let j = 0; j < config.gridSize; j++) {
            const index = i * config.gridSize + j;
            
            // Calculate position
            const x = i * config.cellSize - offset;
            const z = j * config.cellSize - offset;
            
            // Calculate distance from center
            const dx = i - centerX;
            const dz = j - centerZ;
            const distanceToCenter = Math.sqrt(dx * dx + dz * dz);
            
            // Store building data
            buildings.push({
              position: new THREE.Vector3(x, 0, z),
              currentHeight: config.baseHeight,
              targetHeight: config.baseHeight,
              index,
              i,
              j,
              distanceToCenter,
              natureEffect: 0
            });
            
            // Set initial matrix
            dummy.position.set(x, 0, z);
            dummy.scale.set(1, config.baseHeight, 1);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(index, dummy.matrix);
          }
        }
        
        instancedMesh.instanceMatrix.needsUpdate = true;
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function onMouseMove(event) {
        // Update mouse position
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      
      function onClick() {
        const currentTime = clock.getElapsedTime();
        
        // Increase heartbeat level
        heartbeatLevel = Math.min(1, heartbeatLevel + 0.2);
        
        // Track click frequency for anxiety
        if (currentTime - lastClickTime < 0.5) {
          clickCount++;
          if (clickCount > 3) {
            anxietyLevel = Math.min(1, anxietyLevel + 0.2);
          }
        } else {
          clickCount = Math.max(0, clickCount - 1);
        }
        
        lastClickTime = currentTime;
      }
      
      function resetBreathing() {
        heartbeatLevel = 0;
        anxietyLevel = 0;
        clickCount = 0;
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        const deltaTime = clock.getDelta();
        const elapsedTime = clock.getElapsedTime();
        
        // Update controls
        controls.update();
        
        // Update raycaster for hover effect
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);
        let hoverPoint = null;
        
        if (intersects.length > 0) {
          const point = intersects[0].point;
          
          // Convert to grid coordinates
          const gridX = (point.x + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          const gridZ = (point.z + (config.gridSize * config.cellSize) / 2) / config.cellSize;
          
          hoverPoint = new THREE.Vector2(gridX, gridZ);
        }
        
        // Gradually reduce heartbeat and anxiety levels
        heartbeatLevel = Math.max(0, heartbeatLevel - deltaTime * 0.1);
        anxietyLevel = Math.max(0, anxietyLevel - deltaTime * 0.05);
        
        // Update buildings
        updateBuildings(deltaTime, elapsedTime, hoverPoint);
        
        // Update material color based on anxiety level
        updateCityMood(elapsedTime);
        
        // Render scene
        renderer.render(scene, camera);
      }
      
      function updateBuildings(deltaTime, elapsedTime, hoverPoint) {
        const smooth = 0.15;
        const dt60 = deltaTime * 60;
        const smoothFactor = 1 - Math.pow(1 - smooth, dt60);
        
        // Calculate breathing parameters based on heartbeat level
        const breatheSpeed = config.breatheSpeed * (1 + heartbeatLevel * 3);
        
        // Reset nature effect on all buildings
        for (const building of buildings) {
          building.natureEffect = 0;
        }
        
        // Apply nature effect to buildings near hover point
        if (hoverPoint) {
          for (const building of buildings) {
            const dx = building.i - hoverPoint.x;
            const dz = building.j - hoverPoint.y;
            const distanceToHover = Math.sqrt(dx * dx + dz * dz);
            
            if (distanceToHover < config.hoverRadius) {
              building.natureEffect = 1 - distanceToHover / config.hoverRadius;
            }
          }
        }
        
        // Update each building
        for (const building of buildings) {
          // Calculate base height with breathing effect
          const localPhase = building.distanceToCenter * config.phaseOffset;
          const localAmplitude = config.baseAmplitude * Math.exp(-building.distanceToCenter * config.amplitudeFalloff);
          
          let targetHeight = config.baseHeight + 
            Math.sin(elapsedTime * breatheSpeed + localPhase) * localAmplitude;
          
          // Add anxiety jitter
          if (anxietyLevel > 0) {
            targetHeight += (Math.random() - 0.5) * anxietyLevel * 0.5;
          }
          
          // Add nature effect (make buildings taller)
          if (building.natureEffect > 0) {
            targetHeight += building.natureEffect * 1.5;
          }
          
          // Ensure minimum height
          targetHeight = Math.max(0.1, targetHeight);
          
          // Smooth transition to target height
          building.targetHeight = targetHeight;
          building.currentHeight += (building.targetHeight - building.currentHeight) * smoothFactor;
          
          // Update matrix
          dummy.position.copy(building.position);
          dummy.position.y = building.currentHeight / 2;
          dummy.scale.set(1, building.currentHeight, 1);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(building.index, dummy.matrix);
        }
        
        instancedMesh.instanceMatrix.needsUpdate = true;
      }
      
      function updateCityMood(elapsedTime) {
        // Base colors
        const calmColor = new THREE.Color(0x88ccff);
        const calmEmissive = new THREE.Color(0x0055aa);
        
        const anxiousColor = new THREE.Color(0xff5500);
        const anxiousEmissive = new THREE.Color(0x550000);
        
        // Start with calm color
        let finalColor = calmColor.clone();
        let finalEmissive = calmEmissive.clone();
        
        // Blend with anxious color based on anxiety level
        if (anxietyLevel > 0) {
          finalColor.lerp(anxiousColor, anxietyLevel);
          finalEmissive.lerp(anxiousEmissive, anxietyLevel);
        }
        
        // Check if any buildings have nature effect
        let hasNatureEffect = false;
        let maxNatureEffect = 0;
        
        for (const building of buildings) {
          if (building.natureEffect > 0) {
            hasNatureEffect = true;
            maxNatureEffect = Math.max(maxNatureEffect, building.natureEffect);
          }
        }
        
        // If there's nature effect, blend with nature color
        if (hasNatureEffect) {
          const natureColor = new THREE.Color(0x00cc44);
          const natureEmissive = new THREE.Color(0x005522);
          finalColor.lerp(natureColor, maxNatureEffect * 0.3);
          finalEmissive.lerp(natureEmissive, maxNatureEffect * 0.3);
          instancedMesh.material.emissiveIntensity = config.emissiveIntensity * 1.5;
          instancedMesh.material.shininess = config.glassShininess * 1.5;
        } else {
          instancedMesh.material.emissiveIntensity = config.emissiveIntensity;
          instancedMesh.material.shininess = config.glassShininess;
        }
        
        // Subtle color pulsing
        const pulseAmount = Math.sin(elapsedTime * 0.5) * 0.05 + 0.95;
        finalColor.multiplyScalar(pulseAmount);
        
        // Update material colors
        instancedMesh.material.color.copy(finalColor);
        instancedMesh.material.emissive.copy(finalEmissive);
        
        // Update opacity based on anxiety (more transparent when anxious)
        instancedMesh.material.opacity = config.glassOpacity * (1 - anxietyLevel * 0.2);
      }
    });
  </script>
</body>
</html>